package javaAss4;import java.io.File;import java.util.*;public class Assignment4 {    public static void main(String[] args) throws Exception{        Scanner in = new Scanner(new File(args[0]));        Network trainSystem = new Network(Float.parseFloat(args[3]));        String vertex,sdq,tim,tom;        String[] tp;        float ok ;        while (in.hasNextLine()){            tp = in.nextLine().split(":");            vertex = tp[0];            tp = tp[1].split(">");            sdq = tp[1];            trainSystem.addIntersevtion(vertex,sdq);        }        in.close();        in = new Scanner(new File(args[1]));        while (in.hasNextLine()){            tp=in.nextLine().split(" ");            vertex = tp[0].split("-")[0];            sdq = tp[0].split("-")[1];            trainSystem.addRail(vertex,sdq,Float.parseFloat(tp[1]));        }        in.close();        in = new Scanner(new File(args[2]));        while (in.hasNextLine()){            sdq=in.nextLine();            System.out.println("COMMAND IN PROCESS >> "+sdq);            tp=sdq.split(" ");            if(tp[0].compareTo("ROUTE")==0){                ok=Float.parseFloat(tp[2]);                tp=tp[1].split(">");                trainSystem.dijkstra(tp[0],tp[1],ok);            }            else if(tp[0].compareTo("BREAK")==0){                tp=tp[1].split(">");                trainSystem.breakF(tp[0],tp[1]);            }            else if(tp[0].compareTo("REPAIR")==0){                tp=tp[1].split(">");                trainSystem.repairF(tp[0],tp[1]);            }            else if(tp[0].compareTo("MAINTAIN")==0)                trainSystem.maintainF(tp[1]);            else if(tp[0].compareTo("SERVICE")==0)                trainSystem.serviceF(tp[1]);            else if(tp[0].compareTo("ADD")==0)                trainSystem.addIntersevtion(tp[1],tp[1]);            else if(tp[0].compareTo("LINK")==0){                tp=tp[1].split(":");                vertex = tp[0];                tp = tp[1].split(">");                tim=tp[1];                tp=tp[0].split(",");                trainSystem.addIntersevtion(vertex,tim);                for(String elem:tp){                    tom = elem.split("-")[0];                    ok=Float.parseFloat(elem.split("-")[1]);                    trainSystem.addRail(vertex,tom,ok);                }            }            else if(tp[0].compareTo("LISTROUTESFROM")==0)                trainSystem.listRoutesFrom(tp[1]);            else if(tp[0].compareTo("LISTMAINTAINS")==0)                trainSystem.listMaintains();            else if(tp[0].compareTo("LISTACTIVERAILS")==0)                trainSystem.listActiveRails();            else if(tp[0].compareTo("LISTBROKENRAILS")==0)                trainSystem.listBrokenRails();            else if(tp[0].compareTo("LISTCROSSTIMES")==0)                trainSystem.listCrossTimes();            else if(tp[0].compareTo("TOTALNUMBEROFJUNCTIONS")==0)                trainSystem.totalNumberofJunctions();            else if(tp[0].compareTo("TOTALNUMBEROFRAILS")==0)                trainSystem.totalNumberofRails();            else{                System.out.print("\tUnrecognized command \""+tp[0]+"\"!");                continue;            }            System.out.println("\tCommand \""+sdq+"\"  has been executed successfully!");        }        in.close();    }}class Network{    class Rail{        Intersection source,destination;        boolean isActive,isBroken;        float distance;        Rail(Intersection from,Intersection to, float distance){            this.source = from;            this.destination = to;            this.distance = distance;            this.isActive= true;            this.isBroken=false;        }    }    class Intersection{        String name,switchDirection;        boolean underMaintance;        int totalPasses;        List<Rail> adj;        Intersection(String name,String switchDirection){            this.name=name;            this.totalPasses=0;            this.underMaintance=false;            this.switchDirection = switchDirection;            this.adj = new LinkedList<>();        }        void addRaill(Intersection dest,float lenn){            this.adj.add(new Rail(this,dest,lenn));        }    }    Map<String, Intersection> vertices;    float switchChangeTime;    int swtcN;    Network(float time){        this.vertices = new HashMap<>();        this.switchChangeTime = time;    }    void addIntersevtion(String name,String switchDirection){        this.vertices.put(name,new Intersection(name,switchDirection));    }    void addRail(String from, String to, float length){        this.vertices.get(from).addRaill(this.vertices.get(to),length);        this.vertices.get(to).addRaill(this.vertices.get(from),length);    }    void dijkstra(String source,String destination,float velocity){        this.swtcN=0;        Map<String,Float> disto = new HashMap<>();        Map<String,Rail> edgeto = new HashMap<>();        priortyQueue pq = new priortyQueue();        for(String elem:this.vertices.keySet())            disto.put(elem, Float.MAX_VALUE);        disto.put(source, (float) 0);        pq.enqueue(source,(float) 0);        while (!pq.isEmpty()){            priortyQueue.qNode v = pq.delMin();            for(Rail elem: this.vertices.get(v.data).adj){                if(!elem.isBroken && !elem.destination.underMaintance) {                    String fr = elem.source.name, tt = elem.destination.name;                    float plus = 0;                    if (this.vertices.get(fr).switchDirection.compareTo(this.vertices.get(tt).name) != 0)                        plus += switchChangeTime;                    if (disto.get(tt) > (disto.get(fr) + plus + ((elem.distance) / velocity) * 60)) {                        disto.put(tt, disto.get(fr) + plus + ((elem.distance) / velocity) * 60);                        edgeto.put(tt, elem);                        pq.contains(tt);                        pq.enqueue(tt, disto.get(tt));                    }                }            }        }        //String.format("%.3f%n",disto.get(destination))        if(disto.get(destination) != Float.MAX_VALUE){            switctNumber(edgeto,source,destination,destination);            System.out.print("\tTime (in min): "+ String.format("%.3f%n",disto.get(destination)).replace(".",",") +"\t"+                            "Total # of switch changes: "+this.swtcN+"\n\tRoute from "+source+" to "+destination+":");                            printPath(edgeto,source,destination);            System.out.print("\n");        }        else           System.out.print("\tNo route from "+source+" to "+destination+" found currently!\n");    }    void printPath(Map<String,Rail> pat,String s,String d){        if(d.compareTo(s)!=0)            printPath(pat, s, pat.get(d).source.name);        this.vertices.get(d).totalPasses++;        System.out.print(" "+d);    }    void switctNumber(Map<String,Rail> pat,String s,String d,String prev){        if(d.compareTo(s)!=0)            switctNumber(pat, s, pat.get(d).source.name,d);        if( prev.compareTo(d)!=0 && this.vertices.get(d).switchDirection.compareTo(prev)!=0){            //System.out.print("< d: "+d+" prev: "+prev+" vertices.get(d).switchDirection: "+this.vertices.get(d).switchDirection+">\n");            this.vertices.get(d).switchDirection=prev;            this.swtcN++;        }    }    void breakF(String source,String dest){        for(Rail elem:this.vertices.get(source).adj){            if(elem.destination.name.compareTo(dest)==0){                elem.isBroken=true;                break;            }        }    }    void repairF(String source,String dest){        for(Rail elem:this.vertices.get(source).adj){            if(elem.destination.name.compareTo(dest)==0){                elem.isBroken=false;                break;            }        }    }    void maintainF(String intersec){        this.vertices.get(intersec).underMaintance=true;    }    void serviceF(String intersec){        this.vertices.get(intersec).underMaintance=false;    }    void listRoutesFrom(String sour){        priortyQueue pq = new priortyQueue();        for(Rail elem:this.vertices.get(sour).adj)            pq.enqueue(elem.destination.name);        System.out.print("\tRoutes from "+sour+":");        pq.printt();    }    void listMaintains(){        priortyQueue pq = new priortyQueue();        System.out.print("\tIntersections under maintenance:");        for(Map.Entry<String, Intersection> ent : this.vertices.entrySet()){            if(ent.getValue().underMaintance)                pq.enqueue(ent.getKey());        }        pq.printt();    }    void listActiveRails(){        priortyQueue pq = new priortyQueue();        System.out.print("\tActive Rails:");        for(Map.Entry<String, Intersection> ent : this.vertices.entrySet()){            for(Rail elem : ent.getValue().adj){                if(ent.getValue().switchDirection.compareTo(elem.destination.name)==0)                    pq.enqueue(ent.getKey()+">"+elem.destination.name);            }        }        pq.printt();    }    void listBrokenRails(){        priortyQueue pq = new priortyQueue();        System.out.print("\tBroken rails:");        for(Map.Entry<String, Intersection> ent : this.vertices.entrySet()){            for(Rail elem : ent.getValue().adj){                if(elem.isBroken)                    pq.enqueue(ent.getKey()+">"+elem.destination.name);            }        }        pq.printt();    }    void listCrossTimes(){        System.out.print("\t# of cross times:");        priortyQueue pq = new priortyQueue();        int tps;        for(Map.Entry<String, Intersection> ent : this.vertices.entrySet()){            tps=ent.getValue().totalPasses;            if(tps>0)                pq.enqueue(ent.getKey()+":"+tps);        }        pq.printt();    }    void totalNumberofJunctions(){        System.out.print("\tTotal # of junctions: "+this.vertices.size()+"\n");    }    void totalNumberofRails(){        System.out.print("\tTotal # of rails: ");        int numof=0;        for(Map.Entry<String, Intersection> ent : this.vertices.entrySet()){            numof+=ent.getValue().adj.size();        }        System.out.print(numof+"\n");    }}class priortyQueue {    class qNode {        String data,tt;        float value;        qNode left, right;        qNode(String item,float len) {            this.data = item;            this.value = len;            this.left = this.right = null;        }        qNode(String elem){            this.data = elem;            this.left = this.right = null;        }        qNode(String fr,String to){            this.data = fr;            this.tt = to;            this.left = this.right = null;        }    }    qNode rear,front;    boolean isEmpty(){return this.rear == null;}    priortyQueue(){        this.rear=this.front=null;    }    void delete(qNode del){        if(del == this.rear)            this.rear = this.rear.left;        else if(del==this.front)            this.front = this.front.right;        else{            del.right.left=del.left;            del.left.right = del.right;        }    }    void contains(String search){        qNode tem = this.front;        while (tem!=null){            if(tem.data.compareTo(search)==0){                delete(tem);                return;            }            tem = tem.right;        }    }    qNode delMin(){        qNode te = this.rear;        if(this.rear==this.front)            this.rear=this.front=null;        else{            this.rear = this.rear.left;            this.rear.right = null;        }        return te;    }    void enqueue(String vertex, float leng){        qNode t = new qNode(vertex,leng);        if(isEmpty())            rear=front=t;        else{            qNode tem = front;            while(tem != null && leng<tem.value)                tem=tem.right;            if(tem==null){                rear.right=t;                t.left=rear;                rear=t;            }            else if(tem==front){                t.right=front;                front.left=t;                front=t;            }            else{                tem.left.right=t;                t.left=tem.left;                t.right=tem;                tem.left=t;            }        }    }    void enqueue(String vertex){        qNode t = new qNode(vertex);        if(isEmpty())            rear=front=t;        else{            qNode tem = front;            while(tem != null && tem.data.compareTo(vertex)<0)                tem=tem.right;            if(tem==null){                rear.right=t;                t.left=rear;                rear=t;            }            else if(tem==front){                t.right=front;                front.left=t;                front=t;            }            else{                tem.left.right=t;                t.left=tem.left;                t.right=tem;                tem.left=t;            }        }    }    void printt(){        qNode temp = this.front;        while (temp!=null){            //System.out.print("<"+temp.data+" "+ temp.value+"> ");            System.out.print(" "+temp.data);            temp=temp.right;        }        System.out.print("\n");    }}