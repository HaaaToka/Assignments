package javaAss3;import javafx.util.Pair;import java.io.File;import java.io.FileNotFoundException;import java.io.PrintWriter;import java.util.*;class assignment3 {    public static void main(String[] args) throws Exception{        Scanner in = new Scanner(new File(args[0]));        PrintWriter out = new PrintWriter(new File(args[2]));        List<String> nodes = new ArrayList<>();        Set<String> nom = new LinkedHashSet<>();        Graph gr=new Graph();        String t;        String[] ta;        double d;        while (in.hasNext()){            t=in.next();            t=t.substring(1,t.length()-1);            gr.addVertex(t);            for( int i = 0 ; i < 50; i++)                gr.vertexVector(t,i,in.nextDouble());        }        in=new Scanner(new File(args[1]));        while (in.hasNext()){            ta=in.next().split("-");            nom.add(ta[0]);nom.add(ta[1]);            //System.out.println(ta[0]+" "+ta[1]);        }        for(String elem:nom)            nodes.add(elem);        int lenn = nodes.size();        gr.creatEdges(lenn);        for(int i=0;i<lenn;i++){            for (int k=i+1;k<lenn;k++){                gr.addEdge(nodes.get(i),nodes.get(k));            }        }        //gr.printNeigh("woman");        gr.primsMST(lenn,"day",Integer.parseInt(args[3])-1,out);        System.out.println(lenn);        //gr.quicksort(0,gr.ec-1);        //gr.allEdges();    }}class Graph{    Map<String , Node> map;    String[][] edges;    int ec;    class Node{        String data;        double[] vector;        List<Pair<String,Double>> neigh;        boolean cycleDetection;        Node(String data){            this.data=data;            this.vector = new double[50];            this.neigh = new ArrayList<>();            this.cycleDetection = true;        }        Node(String name,boolean cycle){            this.cycleDetection=cycle;            this.data=name;        }    }    Graph(){        this.ec=0;        this.map = new HashMap<>();    }    Graph(int vertexCount){        this.ec=vertexCount;        this.map = new HashMap<>();    }    void creatEdges(int size){        this.edges = new String[(size*(size-1))/2][3];    }    void addVertex(String dota){        this.map.put(dota,new Node(dota));    }    void addVertex(String dota,boolean cycle){        this.map.put(dota,new Node(dota,cycle));    }    void vertexVector(String vertex,int index,double value){        this.map.get(vertex).vector[index]=value;    }    double cosSim(String x, String y){        double lenx=0,leny=0,midres=0;        for(int i=0; i<50; i++){            lenx+=this.map.get(x).vector[i]*this.map.get(x).vector[i];            leny+=this.map.get(y).vector[i]*this.map.get(y).vector[i];            midres+=this.map.get(x).vector[i]*this.map.get(y).vector[i];        }        return (double) (midres/(Math.pow(lenx,0.5)*Math.pow(leny,0.5)));    }    void addEdge(String from, String to){        double simularty=cosSim(from,to);        if(simularty<0) return;        this.map.get(from).neigh.add(new Pair<>(to,simularty));        this.map.get(to).neigh.add(new Pair<>(from,simularty));        this.edges[this.ec][0]=from;        this.edges[this.ec][1]=to;        this.edges[this.ec][2]=Double.toString(simularty);this.ec++;    }    void addEdge(String from,String to,double x){        this.map.get(from).neigh.add(new Pair<>(to,x));        this.map.get(to).neigh.add(new Pair<>(from,x));    }    void primsMST(int vertexCount,String initialVertex,int clusterCount,PrintWriter out){        int willDelete=0;        Double mini,parseKth,sum=0.0;        List<String[]> kenarlar = new ArrayList<>();        List<String[]> mst = new ArrayList<>();        String lastVertex=initialVertex;        this.map.get(lastVertex).cycleDetection=false;        for(int i=0;i<vertexCount-1;i++){            mini=2.0;            for(Pair elem : this.map.get(lastVertex).neigh)                if( this.map.get(elem.getKey().toString()).cycleDetection)                    kenarlar.add(new String[]{lastVertex, elem.getKey().toString(), elem.getValue().toString()});            for(int k=0;k<kenarlar.size();k++){                parseKth=Double.parseDouble(kenarlar.get(k)[2]);                if(parseKth<mini && (this.map.get(kenarlar.get(k)[0]).cycleDetection || this.map.get(kenarlar.get(k)[1]).cycleDetection)){                    mini=parseKth;                    willDelete=k;                }            }            mst.add(kenarlar.get(willDelete));            lastVertex=kenarlar.get(willDelete)[1];            this.map.get(lastVertex).cycleDetection=false;            kenarlar.remove(willDelete);        }        boolean swapped;        String[] temp;        for(int l=0;l<mst.size()-1;l++){            swapped=false;            for (int j=0;j<mst.size()-l-1;j++){                if(Double.parseDouble(mst.get(j)[2])>Double.parseDouble(mst.get(j+1)[2])){                    temp=mst.get(j);                    mst.set(j,mst.get(j+1));                    mst.set(j+1,temp);                    swapped=true;                }            }            if(!swapped) break;        }        Graph mstGra = new Graph(vertexCount);        while(clusterCount-->0) {            temp=mst.remove(clusterCount);            mstGra.addVertex(temp[0],true);            mstGra.addVertex(temp[1],true);        }        System.out.print("\n\n");        for(String[] elem:mst) {            //System.out.println(elem[0] + " " + elem[1] + " " + elem[2]);            System.out.println(elem[0] + "->" + elem[1]);            sum+=Double.parseDouble(elem[2]);        }        System.out.println("\n"+sum+"-->>"+initialVertex+"\n\n");    }    void BFS(PrintWriter out){    }    void allEdges(){        for(int i=0;i<this.ec;i++)            System.out.println(this.edges[i][0]+" "+this.edges[i][1]+" "+this.edges[i][2]);        /*        for(String[] elem:this.edges)            System.out.println(elem[0]+" "+elem[1]+" "+elem[2]);        //System.out.println(elem[0]+" -> "+elem[1]);*/    }    void printNeigh(String x){        for(Pair elem: this.map.get(x).neigh)            System.out.println(elem.getKey()+" "+elem.getValue().toString());    }    void quicksort(int left, int right) {        String[] temp;        double pivot = Double.parseDouble(this.edges[left + (right - left) / 2][2]);        int i = left;        int j = right;        while (i <= j) {            while (Double.parseDouble(this.edges[i][2]) < pivot) {                i++;            }            while (Double.parseDouble(this.edges[j][2]) > pivot) {                j--;            }            if (i <= j) {                temp = this.edges[i];                this.edges[i++] = this.edges[j];                this.edges[j--] = temp;            }        }        //partitaion        if (left < j) quicksort( left, j);        if (i < right) quicksort( i, right);    }}